# indicator4cj 设计架构深度解析

## 1. 核心挑战：从并发模型到同步流模型

Go 原版 `cinar/indicator` 依赖于 `chan Float64` 进行数据传输，实现了天然的并发与惰性计算。在仓颉迁移过程中，我们面临的主要挑战是如何在没有原生 `chan` 语法的环境下保持这种高效的流处理能力。

### 1.1 解决方案：基于 Iterator 的惰性计算管线
我们采用了仓颉的 `Iterator<T>` 接口作为数据流的核心。通过自定义的迭代器（如 `MapIterator`, `Operate3Iterator`），我们构建了一个拉取式（Pull-based）的计算链：
- **数据源**：从 CSV 或 API 读取并返回迭代器。
- **中间转换**：每个指标消费上游迭代器，并返回一个新的迭代器。
- **物化**：只有在最终回测或打印结果时，才会真正触发计算。

### 1.2 解决多路消费问题
由于 `Iterator` 通常是不可重复消费的，而许多指标需要同时处理（例如计算 Bollinger Bands 需要同时得到中轨、上轨和下轨），我们实现了 `helper.Duplicate(iter, n)`。
- **原理**：底层使用缓冲队列。当其中一个副本超前读取时，数据会进入队列供其他副本后续读取。当所有副本都消费完某一元素时，该元素才从内存中释放。

## 2. 反射与 DTO 解析的设计逻辑

由于仓颉标准库对 `struct` 的反射支持（如动态设置字段值）存在一定限制，本项目在数据传输对象（DTO，如 `Snapshot` 和 `Result`）的设计上做出了关键权衡：

- **Class vs Struct**：对于需要通过 CSV 或数据库动态加载的数据模型，我们优先使用 `class` 并配合 `var` 字段。这确保了反射工具链（`ClassTypeInfo`）能够正确实例化并填充数据。
- **反射工具集**：在 `helper/reflect.cj` 中封装了一套安全转换层，能够自动处理 `String` 到 `Float64`, `DateTime`, `Int64` 等常用金融类型的转换。

## 3. 策略引擎的设计：装饰器模式应用

为了实现高度模块化且可重用的交易策略，`indicator4cj` 采用了经典的**装饰器模式 (Decorator Pattern)**。

- **Strategy 接口**：定义了统一的 `Compute` 接口，输入快照流，输出动作流。
- **装饰器链**：
  - 一个原始策略（如 `RsiStrategy`）可以被 `StopLossStrategy` 包裹以增加止损功能。
  - `StopLossStrategy` 还可以进一步被 `InverseStrategy` 包裹以进行反向回测。
这种设计允许我们在不修改核心逻辑的情况下，像搭积木一样组合出极其复杂的风控逻辑。

## 4. 数据一致性保证机制

金融库的生命线在于计算精度。为了确保迁移后的代码与 Go 原版 100% 一致：
1. **对齐预热期 (IdlePeriod)**：每个指标都明确了其预热期。我们使用 `Shift` 和 `Skip` 算子来确保输出序列的偏移量与 Go 完全匹配。
2. **1:1 交叉验证测试**：
   - 提取 Go 版计算出的 CSV 结果。
   - 在仓颉中输入相同的原始数据。
   - 使用 `CheckEquals` 辅助函数（支持 epsilon 容差）对比每一行输出。

## 5. 回测引擎与报告生成

回测引擎采用单线程同步循环（可通过多资产并行加速），旨在提供确定性极高的结果。
- **佣金模型**：支持比例佣金计算。
- **报告解耦**：通过 `Report` 接口将计算结果与展示形式解耦。`HtmlReport` 使用了预定义的模板字符串拼接，生成无需外部依赖的单文件 HTML 报表。